{
  "name": "Precision Medicine Engine - Main Orchestrator",
  "notes": "PRECISION MEDICINE ENGINE - MAIN ORCHESTRATOR (v1.0.0)\n=====================================================\n\nPurpose: Core workflow that handles the full user query lifecycle.\n\nFlow Summary:\n1. Webhook receives user query (POST /webhook/precision-medicine-query)\n2. Input is sanitized (XSS/injection prevention) and classified for PHI content\n3. If PHI detected: routed through Ollama llama3.1:8b for local redaction\n4. DeepSeek Coder v2 generates a context-aware Cypher query from natural language\n5. Cypher is validated/sanitized (write ops blocked, LIMIT enforced)\n6. Dynamic Cypher executes against Neo4j for cache lookup\n7. Cache HIT: return cached data immediately\n8. Cache MISS: fetch from OpenClaw (PubMed, ClinicalTrials, DrugBank, etc.)\n9. Ollama validates fetched data for medical accuracy\n10. Validated data stored in Neo4j as entities + relationships\n11. Audit log persisted, response returned with compliance headers\n\nMaintenance Lane (runs daily):\n- Purges stale data older than 30 days (excludes audit logs)\n- Verifies Neo4j indexes exist for all entity types\n- Health-checks Ollama service, alerts if down\n\nDependencies:\n- Neo4j (bolt://localhost:7687) with APOC plugin\n- Ollama (http://localhost:11434) with llama3.1:8b and deepseek-coder-v2\n- OpenClaw API (configurable via OPENCLAW_API_URL env var)\n\nCredentials Required:\n- neo4j-cred-1: Neo4j database connection\n- OPENCLAW_API_KEY: environment variable for OpenClaw auth\n\nSee ARCHITECTURE.md for inter-workflow coordination details.",
  "nodes": [
    {
      "parameters": {
        "httpMethod": "POST",
        "path": "precision-medicine-query",
        "responseMode": "responseNode",
        "options": {
          "rawBody": true
        }
      },
      "id": "node-webhook-intake",
      "name": "User Query Intake",
      "type": "n8n-nodes-base.webhook",
      "typeVersion": 2,
      "position": [220, 300],
      "webhookId": "precision-medicine-query",
      "notes": "ENTRY POINT: Receives user medical queries via POST.\nExpected JSON body: { query: string, user_id?: string, session_id?: string }\nResponse is deferred to the 'Respond to User' node at the end of the pipeline.\nrawBody is enabled to preserve the original payload for audit purposes.",
      "notesInFlow": true
    },
    {
      "parameters": {
        "jsCode": "const body = $input.first().json.body;\n\nconst userQuery = body.query || '';\nconst userId = body.user_id || 'anonymous';\nconst sessionId = body.session_id || $execution.id;\nconst queryTimestamp = new Date().toISOString();\n\n// Basic input sanitization\nconst sanitizedQuery = userQuery\n  .replace(/[<>\"'`;]/g, '')\n  .trim()\n  .substring(0, 2000);\n\nif (!sanitizedQuery) {\n  throw new Error('Query cannot be empty after sanitization.');\n}\n\n// Check if query contains PHI indicators for routing to Ollama\nconst phiPatterns = [\n  /\\b\\d{3}-\\d{2}-\\d{4}\\b/,      // SSN\n  /\\b[A-Z]{1,2}\\d{6,10}\\b/,      // MRN patterns\n  /\\bpatient\\s+name\\b/i,\n  /\\bdate\\s+of\\s+birth\\b/i,\n  /\\bDOB\\b/,\n  /\\bSSN\\b/i,\n  /\\bmedical\\s+record\\b/i\n];\n\nconst containsPHI = phiPatterns.some(p => p.test(sanitizedQuery));\n\nreturn [\n  {\n    json: {\n      query: sanitizedQuery,\n      user_id: userId,\n      session_id: sessionId,\n      timestamp: queryTimestamp,\n      contains_phi: containsPHI,\n      original_length: userQuery.length,\n      sanitized_length: sanitizedQuery.length\n    }\n  }\n];"
      },
      "id": "node-sanitize-input",
      "name": "Sanitize & Classify Input",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [440, 300],
      "notes": "SECURITY GATE: Sanitizes user input and detects PHI.\n- Strips dangerous characters: < > \" ' ` ;\n- Enforces max 2000 character limit\n- Rejects empty queries after sanitization\n- Scans for PHI patterns (SSN, MRN, DOB, patient names)\n- Sets contains_phi flag to route through Ollama redaction if needed\n\nOutputs: query, user_id, session_id, timestamp, contains_phi",
      "notesInFlow": true
    },
    {
      "parameters": {
        "conditions": {
          "options": {
            "caseSensitive": false,
            "leftValue": "",
            "typeValidation": "strict"
          },
          "conditions": [
            {
              "id": "phi-check",
              "leftValue": "={{ $json.contains_phi }}",
              "rightValue": true,
              "operator": {
                "type": "boolean",
                "operation": "equals",
                "singleValue": true
              }
            }
          ],
          "combinator": "and"
        },
        "options": {}
      },
      "id": "node-phi-router",
      "name": "PHI Data Router",
      "type": "n8n-nodes-base.if",
      "typeVersion": 2,
      "position": [660, 300],
      "notes": "BRANCH: Routes based on PHI detection.\n- TRUE (output 0): Query contains PHI -> sent to Ollama for local redaction\n- FALSE (output 1): No PHI detected -> sent directly to DeepSeek Cypher generation\n\nThis ensures PHI is never passed to external services or stored in raw form.",
      "notesInFlow": true
    },
    {
      "parameters": {
        "method": "POST",
        "url": "http://localhost:11434/api/generate",
        "sendBody": true,
        "specifyBody": "json",
        "jsonBody": "={\n  \"model\": \"llama3.1:8b\",\n  \"prompt\": \"You are a medical data privacy filter. Redact all PHI (Protected Health Information) from the following query while preserving the medical/scientific intent. Replace PHI with generic placeholders. Return ONLY the redacted query.\\n\\nOriginal query: {{ $json.query }}\",\n  \"stream\": false,\n  \"options\": {\n    \"temperature\": 0.1,\n    \"num_predict\": 500\n  }\n}",
        "options": {
          "timeout": 60000
        }
      },
      "id": "node-ollama-redact",
      "name": "Ollama PHI Redaction",
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.2,
      "position": [880, 200],
      "notes": "LOCAL LLM: Calls Ollama llama3.1:8b to redact PHI from the query.\nModel: llama3.1:8b | Temperature: 0.1 (deterministic) | Timeout: 60s\n\nThe prompt instructs the model to replace PHI with generic placeholders\nwhile preserving the medical/scientific intent of the query.\n\nIMPORTANT: This runs entirely on localhost:11434 -- no data leaves the machine.",
      "notesInFlow": true
    },
    {
      "parameters": {
        "jsCode": "const ollamaResponse = $input.first().json;\nconst originalData = $('Sanitize & Classify Input').first().json;\n\nconst redactedQuery = ollamaResponse.response || originalData.query;\n\nreturn [\n  {\n    json: {\n      ...originalData,\n      query: redactedQuery.trim(),\n      original_query_redacted: true,\n      phi_handling: 'ollama_local_redaction'\n    }\n  }\n];"
      },
      "id": "node-merge-redacted",
      "name": "Merge Redacted Query",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [1100, 200],
      "notes": "TRANSFORM: Merges Ollama's redacted query back into the main data payload.\nReplaces the original query with the redacted version.\nFlags the record with original_query_redacted=true and phi_handling='ollama_local_redaction'\nso downstream nodes know PHI processing occurred.\n\nFalls back to original query if Ollama returns empty response.",
      "notesInFlow": false
    },
    {
      "parameters": {
        "method": "POST",
        "url": "http://localhost:11434/api/generate",
        "sendBody": true,
        "specifyBody": "json",
        "jsonBody": "={\n  \"model\": \"deepseek-coder-v2:latest\",\n  \"prompt\": \"You are a Neo4j Cypher query expert. Generate a single valid Cypher READ query to find data relevant to the user's medical query in a precision medicine knowledge graph.\\n\\nGraph Schema:\\n- Node labels: Gene, Drug, Condition, MedicalRecord, AuditLog, PHIAuditLog, ValidationReport\\n- Gene properties: name, symbol, chromosome, description, source, ncbi_id, data, created_at, updated_at\\n- Drug properties: name, generic_name, brand_name, mechanism, indications, drugbank_id, source, data, created_at, updated_at\\n- Condition properties: name, icd10_code, description, category, omim_id, source, data, created_at, updated_at\\n- MedicalRecord properties: name, description, source, data, type, created_at, updated_at\\n- Relationship types: RELATES_TO, TREATS, TARGETS, ASSOCIATED_WITH, INTERACTS_WITH, CAUSES, PREVENTS\\n\\nRules:\\n1. Return ONLY the Cypher query, no explanation or markdown\\n2. Always use LIMIT 20\\n3. Use toLower() for case-insensitive matching\\n4. Use CONTAINS for flexible text search\\n5. Search across relevant node labels based on the query context\\n6. Never use WRITE operations (CREATE, MERGE, DELETE, SET)\\n7. Return nodes and their relationships where possible\\n\\nUser query: {{ $json.query }}\",\n  \"stream\": false,\n  \"options\": {\n    \"temperature\": 0.1,\n    \"num_predict\": 500,\n    \"top_k\": 1,\n    \"stop\": [\"```\", \"\\n\\n\\n\"]\n  }\n}",
        "options": {
          "timeout": 60000
        }
      },
      "id": "node-deepseek-cypher",
      "name": "DeepSeek Generate Cypher",
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.2,
      "position": [1200, 300],
      "notes": "LOCAL LLM: Calls Ollama deepseek-coder-v2 to generate a Cypher query.\nModel: deepseek-coder-v2:latest | Temperature: 0.1 | top_k: 1 | Timeout: 60s\n\nThe prompt provides the full Neo4j graph schema (node labels, properties,\nrelationship types) and strict rules:\n- READ-only queries (no CREATE/MERGE/DELETE/SET)\n- Must use LIMIT 20\n- Case-insensitive matching with toLower()\n- Returns only the raw Cypher, no markdown or explanation\n\nDeepSeek Coder is used instead of llama3.1 because it specializes in\ncode generation and produces more syntactically correct Cypher.\n\nThe output is NOT trusted blindly -- it passes through 'Validate & Sanitize Cypher' next.",
      "notesInFlow": true
    },
    {
      "parameters": {
        "jsCode": "const deepseekResponse = $input.first().json;\nconst queryData = $('Sanitize & Classify Input').first().json;\n\nlet cypherQuery = (deepseekResponse.response || '').trim();\n\n// Strip markdown code fences if present\ncypherQuery = cypherQuery.replace(/^```(?:cypher)?\\n?/i, '').replace(/\\n?```$/i, '').trim();\n\n// Safety: reject any write operations that slipped through\nconst writeOps = /\\b(CREATE|MERGE|DELETE|DETACH|SET|REMOVE|DROP|CALL\\s+\\{)\\b/i;\nif (writeOps.test(cypherQuery)) {\n  // Fallback to a safe generic read query\n  cypherQuery = `MATCH (n)\nWHERE toLower(n.name) CONTAINS toLower('${queryData.query.replace(/'/g, \"\\\\'\")}')\n   OR toLower(coalesce(n.description, '')) CONTAINS toLower('${queryData.query.replace(/'/g, \"\\\\'\")}')\nRETURN n\nLIMIT 20`;\n}\n\n// Ensure LIMIT exists\nif (!/LIMIT\\s+\\d+/i.test(cypherQuery)) {\n  cypherQuery += '\\nLIMIT 20';\n}\n\n// Validate it looks like a Cypher query\nif (!cypherQuery.toUpperCase().startsWith('MATCH') && !cypherQuery.toUpperCase().startsWith('OPTIONAL') && !cypherQuery.toUpperCase().startsWith('CALL')) {\n  // Fallback to safe generic query\n  cypherQuery = `MATCH (n)\nWHERE toLower(n.name) CONTAINS toLower('${queryData.query.replace(/'/g, \"\\\\'\")}')\n   OR toLower(coalesce(n.description, '')) CONTAINS toLower('${queryData.query.replace(/'/g, \"\\\\'\")}')\nRETURN n\nLIMIT 20`;\n}\n\nreturn [\n  {\n    json: {\n      ...queryData,\n      generated_cypher: cypherQuery,\n      cypher_generator: 'deepseek-coder-v2'\n    }\n  }\n];"
      },
      "id": "node-validate-cypher",
      "name": "Validate & Sanitize Cypher",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [1320, 300],
      "notes": "SECURITY GATE: Validates and sanitizes the LLM-generated Cypher query.\nThree safety checks are applied in order:\n\n1. WRITE OPERATION BLOCKING: Regex rejects CREATE, MERGE, DELETE, DETACH,\n   SET, REMOVE, DROP, CALL{}. Falls back to safe generic query if found.\n2. LIMIT ENFORCEMENT: Appends 'LIMIT 20' if the query lacks one.\n3. STRUCTURE VALIDATION: Query must start with MATCH, OPTIONAL, or CALL.\n   Falls back to safe generic query otherwise.\n\nFallback query: Generic search across all node names and descriptions.\nThis ensures the system never executes destructive or unbounded queries\neven if the LLM hallucinates write operations.",
      "notesInFlow": true
    },
    {
      "parameters": {
        "operation": "executeQuery",
        "query": "={{ $json.generated_cypher }}"
      },
      "id": "node-neo4j-check",
      "name": "Execute Dynamic Cypher",
      "type": "n8n-nodes-base.neo4j",
      "typeVersion": 1,
      "position": [1440, 300],
      "credentials": {
        "neo4j": {
          "id": "neo4j-cred-1",
          "name": "Neo4j Local"
        }
      },
      "notes": "DATABASE: Executes the validated Cypher query against Neo4j.\nThe query comes from $json.generated_cypher (set by Validate & Sanitize Cypher).\n\nThis serves as the cache lookup -- if Neo4j already has relevant data\nfrom a previous OpenClaw fetch, we return it directly without external calls.\n\nCredential: neo4j-cred-1 (configure in n8n credentials with bolt://localhost:7687)",
      "notesInFlow": false
    },
    {
      "parameters": {
        "jsCode": "const neo4jResults = $input.first().json;\nconst queryData = $('Sanitize & Classify Input').first().json;\n\n// Check if we got meaningful results from Neo4j\nconst hasResults = neo4jResults && \n  ((Array.isArray(neo4jResults) && neo4jResults.length > 0) ||\n   (neo4jResults.records && neo4jResults.records.length > 0));\n\nreturn [\n  {\n    json: {\n      ...queryData,\n      neo4j_has_data: hasResults,\n      neo4j_results: hasResults ? neo4jResults : null,\n      cache_status: hasResults ? 'HIT' : 'MISS'\n    }\n  }\n];"
      },
      "id": "node-evaluate-cache",
      "name": "Evaluate Cache Results",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [1540, 300],
      "notes": "DECISION: Evaluates whether Neo4j returned meaningful results.\nChecks for non-empty arrays or records. Sets:\n- neo4j_has_data: boolean (used by Cache Hit Router)\n- cache_status: 'HIT' or 'MISS'\n- neo4j_results: the actual data (null if miss)",
      "notesInFlow": false
    },
    {
      "parameters": {
        "conditions": {
          "options": {
            "caseSensitive": false,
            "leftValue": "",
            "typeValidation": "strict"
          },
          "conditions": [
            {
              "id": "cache-hit",
              "leftValue": "={{ $json.neo4j_has_data }}",
              "rightValue": true,
              "operator": {
                "type": "boolean",
                "operation": "equals",
                "singleValue": true
              }
            }
          ],
          "combinator": "and"
        },
        "options": {}
      },
      "id": "node-cache-router",
      "name": "Cache Hit Router",
      "type": "n8n-nodes-base.if",
      "typeVersion": 2,
      "position": [1760, 300],
      "notes": "BRANCH: Routes based on Neo4j cache results.\n- TRUE (output 0): Cache HIT -> Format Cached Response (fast path, no external calls)\n- FALSE (output 1): Cache MISS -> OpenClaw Research Fetch (external data retrieval)\n\nThe cache-first pattern minimizes external API calls and latency.",
      "notesInFlow": true
    },
    {
      "parameters": {
        "jsCode": "const data = $input.first().json;\n\nreturn [\n  {\n    json: {\n      status: 'success',\n      source: 'local_cache',\n      cache_status: 'HIT',\n      query: data.query,\n      session_id: data.session_id,\n      timestamp: new Date().toISOString(),\n      results: data.neo4j_results,\n      data_freshness: 'cached'\n    }\n  }\n];"
      },
      "id": "node-format-cached",
      "name": "Format Cached Response",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [1980, 200],
      "notes": "TRANSFORM: Formats cached Neo4j results into the standard response envelope.\nSets source='local_cache', data_freshness='cached'.\nThis is the fast path -- no external API calls were needed.",
      "notesInFlow": false
    },
    {
      "parameters": {
        "method": "POST",
        "url": "={{ $env.OPENCLAW_API_URL || 'http://localhost:8080/api/v1/research' }}",
        "sendHeaders": true,
        "headerParameters": {
          "parameters": [
            {
              "name": "Authorization",
              "value": "=Bearer {{ $env.OPENCLAW_API_KEY }}"
            },
            {
              "name": "Content-Type",
              "value": "application/json"
            }
          ]
        },
        "sendBody": true,
        "specifyBody": "json",
        "jsonBody": "={\n  \"query\": \"{{ $json.query }}\",\n  \"context\": \"precision_medicine\",\n  \"sources\": [\n    \"pubmed\",\n    \"clinicaltrials_gov\",\n    \"drugbank\",\n    \"pharmgkb\",\n    \"omim\",\n    \"uniprot\"\n  ],\n  \"max_results\": 50,\n  \"include_citations\": true,\n  \"session_id\": \"{{ $json.session_id }}\"\n}",
        "options": {
          "timeout": 120000,
          "retry": {
            "maxRetries": 3,
            "retryInterval": 2000
          }
        }
      },
      "id": "node-openclaw-fetch",
      "name": "OpenClaw Research Fetch",
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.2,
      "position": [1980, 420],
      "notes": "EXTERNAL API: Calls OpenClaw to aggregate research data from multiple sources.\nSources queried: PubMed, ClinicalTrials.gov, DrugBank, PharmGKB, OMIM, UniProt\n\nConfiguration:\n- URL: from OPENCLAW_API_URL env var (default: http://localhost:8080/api/v1/research)\n- Auth: Bearer token from OPENCLAW_API_KEY env var\n- Timeout: 120s | Retries: 3 with 2s interval\n- Max results: 50 per query\n\nThis node only fires on cache MISS (no local data found in Neo4j).",
      "notesInFlow": true
    },
    {
      "parameters": {
        "jsCode": "const openClawData = $input.first().json;\nconst queryData = $('Evaluate Cache Results').first().json;\n\n// Validate and structure the OpenClaw response\nconst results = openClawData.results || openClawData.data || openClawData;\n\n// Extract key medical entities for Neo4j storage\nconst entities = [];\nconst relationships = [];\n\nif (Array.isArray(results)) {\n  for (const item of results) {\n    // Build entity nodes\n    if (item.type === 'gene' || item.category === 'genomic') {\n      entities.push({\n        type: 'Gene',\n        name: item.name || item.title,\n        source: item.source || 'openclaw',\n        data: JSON.stringify(item)\n      });\n    } else if (item.type === 'drug' || item.category === 'pharmacological') {\n      entities.push({\n        type: 'Drug',\n        name: item.name || item.title,\n        source: item.source || 'openclaw',\n        data: JSON.stringify(item)\n      });\n    } else if (item.type === 'condition' || item.category === 'disease') {\n      entities.push({\n        type: 'Condition',\n        name: item.name || item.title,\n        source: item.source || 'openclaw',\n        data: JSON.stringify(item)\n      });\n    } else {\n      entities.push({\n        type: 'MedicalRecord',\n        name: item.name || item.title || 'Unknown',\n        description: item.description || item.summary || '',\n        source: item.source || 'openclaw',\n        data: JSON.stringify(item)\n      });\n    }\n\n    // Build relationships if present\n    if (item.related_to) {\n      for (const rel of (Array.isArray(item.related_to) ? item.related_to : [item.related_to])) {\n        relationships.push({\n          from: item.name || item.title,\n          to: rel.name || rel,\n          type: rel.relationship || 'RELATES_TO'\n        });\n      }\n    }\n  }\n}\n\nreturn [\n  {\n    json: {\n      query: queryData.query,\n      session_id: queryData.session_id,\n      user_id: queryData.user_id,\n      timestamp: new Date().toISOString(),\n      raw_results: results,\n      entities: entities,\n      relationships: relationships,\n      source: 'openclaw',\n      result_count: entities.length\n    }\n  }\n];"
      },
      "id": "node-process-openclaw",
      "name": "Process OpenClaw Results",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [2200, 420],
      "notes": "TRANSFORM: Parses OpenClaw response into structured entities and relationships.\nEntity classification by type/category:\n- gene/genomic -> Gene node\n- drug/pharmacological -> Drug node\n- condition/disease -> Condition node\n- anything else -> MedicalRecord node\n\nAlso extracts relationship data (related_to fields) for graph edges.\nOutputs: entities[], relationships[], raw_results, result_count",
      "notesInFlow": false
    },
    {
      "parameters": {
        "method": "POST",
        "url": "http://localhost:11434/api/generate",
        "sendBody": true,
        "specifyBody": "json",
        "jsonBody": "={\n  \"model\": \"llama3.1:8b\",\n  \"prompt\": \"You are a medical data validation assistant. Review the following medical data for accuracy, consistency, and completeness. Flag any issues. Return a JSON object with fields: valid (boolean), issues (array of strings), cleaned_data (the validated data).\\n\\nData to validate:\\n{{ JSON.stringify($json.entities) }}\",\n  \"stream\": false,\n  \"options\": {\n    \"temperature\": 0.1,\n    \"num_predict\": 2000\n  }\n}",
        "options": {
          "timeout": 120000
        }
      },
      "id": "node-ollama-validate",
      "name": "Ollama Data Validation",
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.2,
      "position": [2420, 420],
      "notes": "LOCAL LLM: Calls Ollama llama3.1:8b to validate medical data quality.\nModel: llama3.1:8b | Temperature: 0.1 | Timeout: 120s\n\nReviews entities for accuracy, consistency, and completeness.\nReturns JSON: { valid: bool, issues: string[], cleaned_data: object }\n\nThis catches data quality issues before they enter the Neo4j knowledge graph.\nRuns locally -- no medical data sent to external services.",
      "notesInFlow": false
    },
    {
      "parameters": {
        "jsCode": "const ollamaResponse = $input.first().json;\nconst processedData = $('Process OpenClaw Results').first().json;\n\nlet validationResult;\ntry {\n  const responseText = ollamaResponse.response || '{}';\n  // Try to extract JSON from the Ollama response\n  const jsonMatch = responseText.match(/\\{[\\s\\S]*\\}/);\n  validationResult = jsonMatch ? JSON.parse(jsonMatch[0]) : { valid: true, issues: [], cleaned_data: null };\n} catch (e) {\n  validationResult = { valid: true, issues: ['Could not parse validation response'], cleaned_data: null };\n}\n\nconst entities = validationResult.cleaned_data || processedData.entities;\n\nreturn [\n  {\n    json: {\n      ...processedData,\n      entities: entities,\n      validation: {\n        is_valid: validationResult.valid,\n        issues: validationResult.issues || [],\n        validated_at: new Date().toISOString(),\n        validator: 'ollama_llama3.1_8b'\n      }\n    }\n  }\n];"
      },
      "id": "node-parse-validation",
      "name": "Parse Validation Results",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [2640, 420],
      "notes": "TRANSFORM: Parses Ollama's validation JSON response.\nExtracts JSON from the LLM text output using regex matching.\nUses cleaned_data from Ollama if available, otherwise keeps original entities.\nGracefully handles parse failures (defaults to valid=true with warning).\n\nOutputs merged data with validation metadata (is_valid, issues, validator name).",
      "notesInFlow": false
    },
    {
      "parameters": {
        "operation": "executeQuery",
        "query": "=UNWIND $entities AS entity\nMERGE (n {name: entity.name})\nON CREATE SET \n  n.type = entity.type,\n  n.source = entity.source,\n  n.data = entity.data,\n  n.created_at = datetime(),\n  n.updated_at = datetime()\nON MATCH SET\n  n.data = entity.data,\n  n.source = entity.source,\n  n.updated_at = datetime()\nWITH n, entity\nCALL apoc.create.addLabels(n, [entity.type]) YIELD node\nRETURN count(node) as stored_count",
        "parameters": {
          "entities": "={{ $json.entities }}"
        }
      },
      "id": "node-neo4j-store-entities",
      "name": "Store Entities in Neo4j",
      "type": "n8n-nodes-base.neo4j",
      "typeVersion": 1,
      "position": [2860, 360],
      "credentials": {
        "neo4j": {
          "id": "neo4j-cred-1",
          "name": "Neo4j Local"
        }
      },
      "notes": "DATABASE WRITE: Upserts validated entities into Neo4j graph.\nUses MERGE on name to avoid duplicates.\nON CREATE: sets all properties + created_at/updated_at timestamps.\nON MATCH: updates data, source, and updated_at only.\nUses apoc.create.addLabels() to dynamically set node labels (Gene, Drug, etc.).\n\nRequires APOC plugin installed in Neo4j.\nRuns in parallel with 'Store Relationships in Neo4j'.",
      "notesInFlow": true
    },
    {
      "parameters": {
        "operation": "executeQuery",
        "query": "=UNWIND $relationships AS rel\nMATCH (a {name: rel.from})\nMATCH (b {name: rel.to})\nCALL apoc.merge.relationship(a, rel.type, {}, {created_at: datetime()}, b, {}) YIELD rel as r\nRETURN count(r) as relationship_count",
        "parameters": {
          "relationships": "={{ $json.relationships }}"
        }
      },
      "id": "node-neo4j-store-rels",
      "name": "Store Relationships in Neo4j",
      "type": "n8n-nodes-base.neo4j",
      "typeVersion": 1,
      "position": [2860, 520],
      "credentials": {
        "neo4j": {
          "id": "neo4j-cred-1",
          "name": "Neo4j Local"
        }
      },
      "notes": "DATABASE WRITE: Creates relationships between stored entities.\nUses apoc.merge.relationship() for idempotent edge creation.\nRelationship types include: RELATES_TO, TREATS, TARGETS, ASSOCIATED_WITH, etc.\nMatches nodes by name to connect them.\n\nRuns in parallel with 'Store Entities in Neo4j'.\nBoth must complete before 'Format Fresh Response' executes.",
      "notesInFlow": false
    },
    {
      "parameters": {
        "jsCode": "const processedData = $('Parse Validation Results').first().json;\nconst storedEntities = $('Store Entities in Neo4j').first().json;\nconst storedRels = $('Store Relationships in Neo4j').first().json;\n\nreturn [\n  {\n    json: {\n      status: 'success',\n      source: 'openclaw_fresh',\n      cache_status: 'MISS_STORED',\n      query: processedData.query,\n      session_id: processedData.session_id,\n      timestamp: new Date().toISOString(),\n      results: processedData.raw_results,\n      validation: processedData.validation,\n      storage: {\n        entities_stored: storedEntities.stored_count || 0,\n        relationships_stored: storedRels.relationship_count || 0\n      },\n      data_freshness: 'live'\n    }\n  }\n];"
      },
      "id": "node-format-fresh",
      "name": "Format Fresh Response",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [3100, 420],
      "notes": "TRANSFORM: Formats freshly fetched data into the standard response envelope.\nIncludes: validation results, storage counts (entities + relationships stored),\ndata_freshness='live', cache_status='MISS_STORED'.\n\nMerges output from both Neo4j store nodes to report storage summary.",
      "notesInFlow": false
    },
    {
      "parameters": {
        "jsCode": "const data = $input.first().json;\n\n// Audit log entry for compliance\nconst auditEntry = {\n  event_type: 'query_processed',\n  session_id: data.session_id,\n  timestamp: new Date().toISOString(),\n  source: data.source,\n  cache_status: data.cache_status,\n  result_count: data.results ? (Array.isArray(data.results) ? data.results.length : 1) : 0,\n  validation_status: data.validation ? data.validation.is_valid : 'n/a',\n  phi_detected: data.phi_handling ? true : false,\n  compliance_flags: ['HIPAA_COMPLIANT', 'LOCAL_PROCESSING']\n};\n\nreturn [\n  {\n    json: {\n      response: data,\n      audit: auditEntry\n    }\n  }\n];"
      },
      "id": "node-audit-log",
      "name": "Audit Log Entry",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [3320, 300],
      "notes": "COMPLIANCE: Creates a structured audit log entry for every processed query.\nCaptures: event_type, session_id, timestamp, source, cache_status,\nresult_count, validation_status, phi_detected, compliance_flags.\n\nBoth cached and fresh response paths converge here.\nCompliance flags always include HIPAA_COMPLIANT and LOCAL_PROCESSING.",
      "notesInFlow": true
    },
    {
      "parameters": {
        "operation": "executeQuery",
        "query": "=CREATE (a:AuditLog {\n  event_type: $audit.event_type,\n  session_id: $audit.session_id,\n  timestamp: datetime($audit.timestamp),\n  source: $audit.source,\n  cache_status: $audit.cache_status,\n  result_count: $audit.result_count,\n  phi_detected: $audit.phi_detected,\n  compliance_flags: $audit.compliance_flags\n})\nRETURN a",
        "parameters": {
          "audit": "={{ $json.audit }}"
        }
      },
      "id": "node-neo4j-audit",
      "name": "Store Audit Log",
      "type": "n8n-nodes-base.neo4j",
      "typeVersion": 1,
      "position": [3540, 300],
      "credentials": {
        "neo4j": {
          "id": "neo4j-cred-1",
          "name": "Neo4j Local"
        }
      },
      "notes": "DATABASE WRITE: Persists the audit log entry as an :AuditLog node in Neo4j.\nAudit logs are exempt from the 30-day stale data cleanup.\nThis provides a permanent, queryable compliance trail for all operations.",
      "notesInFlow": false
    },
    {
      "parameters": {
        "respondWith": "json",
        "responseBody": "={{ JSON.stringify($('Audit Log Entry').first().json.response) }}",
        "options": {
          "responseHeaders": {
            "entries": [
              {
                "name": "X-Session-Id",
                "value": "={{ $('Audit Log Entry').first().json.response.session_id }}"
              },
              {
                "name": "X-Cache-Status",
                "value": "={{ $('Audit Log Entry').first().json.response.cache_status }}"
              },
              {
                "name": "X-Compliance",
                "value": "HIPAA_LOCAL_PROCESSING"
              }
            ]
          }
        }
      },
      "id": "node-respond-user",
      "name": "Respond to User",
      "type": "n8n-nodes-base.respondToWebhook",
      "typeVersion": 1.1,
      "position": [3760, 300],
      "notes": "EXIT POINT: Returns the final JSON response to the user.\nCustom response headers added:\n- X-Session-Id: for request tracking\n- X-Cache-Status: HIT or MISS_STORED\n- X-Compliance: HIPAA_LOCAL_PROCESSING\n\nThis is the deferred response node for the 'User Query Intake' webhook.",
      "notesInFlow": true
    },
    {
      "parameters": {
        "rule": {
          "interval": [
            {
              "field": "hours",
              "hoursInterval": 24
            }
          ]
        }
      },
      "id": "node-scheduled-cleanup",
      "name": "Daily Maintenance Trigger",
      "type": "n8n-nodes-base.scheduleTrigger",
      "typeVersion": 1.2,
      "position": [220, 640],
      "notes": "MAINTENANCE LANE: Fires every 24 hours.\nTriggers the maintenance pipeline: cleanup -> index verification -> health check.\nThis lane runs independently of the main query processing lane.",
      "notesInFlow": true
    },
    {
      "parameters": {
        "operation": "executeQuery",
        "query": "// Remove stale cached data older than 30 days\nMATCH (n)\nWHERE n.updated_at < datetime() - duration('P30D')\n  AND NOT n:AuditLog\nDETACH DELETE n\nRETURN count(*) as removed_count"
      },
      "id": "node-neo4j-cleanup",
      "name": "Cleanup Stale Neo4j Data",
      "type": "n8n-nodes-base.neo4j",
      "typeVersion": 1,
      "position": [440, 640],
      "credentials": {
        "neo4j": {
          "id": "neo4j-cred-1",
          "name": "Neo4j Local"
        }
      },
      "notes": "MAINTENANCE: Removes cached data nodes older than 30 days.\nExplicitly excludes :AuditLog nodes to preserve compliance trail.\nUses DETACH DELETE to also remove orphaned relationships.\nReturns count of removed nodes for the maintenance report.",
      "notesInFlow": false
    },
    {
      "parameters": {
        "operation": "executeQuery",
        "query": "// Index maintenance - ensure indexes exist\nCREATE INDEX IF NOT EXISTS FOR (g:Gene) ON (g.name);\nCREATE INDEX IF NOT EXISTS FOR (d:Drug) ON (d.name);\nCREATE INDEX IF NOT EXISTS FOR (c:Condition) ON (c.name);\nCREATE INDEX IF NOT EXISTS FOR (m:MedicalRecord) ON (m.name);\nCREATE INDEX IF NOT EXISTS FOR (a:AuditLog) ON (a.session_id);\nRETURN 'indexes_verified' as status"
      },
      "id": "node-neo4j-indexes",
      "name": "Verify Neo4j Indexes",
      "type": "n8n-nodes-base.neo4j",
      "typeVersion": 1,
      "position": [660, 640],
      "credentials": {
        "neo4j": {
          "id": "neo4j-cred-1",
          "name": "Neo4j Local"
        }
      },
      "notes": "MAINTENANCE: Ensures all required indexes exist in Neo4j.\nCreates indexes (IF NOT EXISTS) for: Gene.name, Drug.name,\nCondition.name, MedicalRecord.name, AuditLog.session_id.\nIndexes improve DeepSeek-generated Cypher query performance.",
      "notesInFlow": false
    },
    {
      "parameters": {
        "method": "POST",
        "url": "http://localhost:11434/api/generate",
        "sendBody": true,
        "specifyBody": "json",
        "jsonBody": "{\n  \"model\": \"llama3.1:8b\",\n  \"prompt\": \"Respond with only: OK\",\n  \"stream\": false,\n  \"options\": { \"num_predict\": 5 }\n}",
        "options": {
          "timeout": 10000
        }
      },
      "id": "node-ollama-healthcheck",
      "name": "Ollama Health Check",
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.2,
      "position": [660, 780],
      "continueOnFail": true,
      "notes": "HEALTH CHECK: Pings Ollama with a trivial prompt to verify it's responsive.\nTimeout: 10s | continueOnFail: true (so workflow continues even if Ollama is down).\nResult is evaluated by 'Ollama Status Check' to determine alert status.",
      "notesInFlow": false
    },
    {
      "parameters": {
        "conditions": {
          "options": {
            "caseSensitive": false,
            "leftValue": "",
            "typeValidation": "strict"
          },
          "conditions": [
            {
              "id": "ollama-up",
              "leftValue": "={{ $json.response }}",
              "rightValue": "",
              "operator": {
                "type": "string",
                "operation": "isNotEmpty"
              }
            }
          ],
          "combinator": "and"
        },
        "options": {}
      },
      "id": "node-ollama-status",
      "name": "Ollama Status Check",
      "type": "n8n-nodes-base.if",
      "typeVersion": 2,
      "position": [880, 780],
      "notes": "BRANCH: Checks if Ollama health check returned a non-empty response.\n- TRUE: Ollama is healthy -> Maintenance Report (OK)\n- FALSE: Ollama is down -> Maintenance Report (Alert)\n\nWhen Ollama is down, PHI redaction and data validation are unavailable.",
      "notesInFlow": false
    },
    {
      "parameters": {
        "jsCode": "const cleanupResult = $('Cleanup Stale Neo4j Data').first().json;\nconst indexResult = $('Verify Neo4j Indexes').first().json;\nconst ollamaUp = true;\n\nreturn [\n  {\n    json: {\n      maintenance_report: {\n        timestamp: new Date().toISOString(),\n        stale_records_removed: cleanupResult.removed_count || 0,\n        indexes_status: indexResult.status || 'verified',\n        ollama_status: 'healthy',\n        next_run: new Date(Date.now() + 86400000).toISOString()\n      }\n    }\n  }\n];"
      },
      "id": "node-maintenance-report-ok",
      "name": "Maintenance Report (OK)",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [1100, 720],
      "notes": "REPORT: Generates maintenance summary when all systems are healthy.\nIncludes: stale records removed, index status, Ollama status, next scheduled run.",
      "notesInFlow": false
    },
    {
      "parameters": {
        "jsCode": "const cleanupResult = $('Cleanup Stale Neo4j Data').first().json;\nconst indexResult = $('Verify Neo4j Indexes').first().json;\n\nreturn [\n  {\n    json: {\n      maintenance_report: {\n        timestamp: new Date().toISOString(),\n        stale_records_removed: cleanupResult.removed_count || 0,\n        indexes_status: indexResult.status || 'verified',\n        ollama_status: 'DOWN - ATTENTION REQUIRED',\n        alert: 'Ollama service is not responding. PHI redaction unavailable.',\n        next_run: new Date(Date.now() + 86400000).toISOString()\n      }\n    }\n  }\n];"
      },
      "id": "node-maintenance-report-fail",
      "name": "Maintenance Report (Alert)",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [1100, 860],
      "notes": "ALERT: Generates maintenance summary with Ollama DOWN warning.\nSets alert message: 'Ollama service is not responding. PHI redaction unavailable.'\nThis indicates the system cannot safely process queries containing PHI\nuntil Ollama is restored.",
      "notesInFlow": true
    }
  ],
  "connections": {
    "User Query Intake": {
      "main": [
        [
          {
            "node": "Sanitize & Classify Input",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Sanitize & Classify Input": {
      "main": [
        [
          {
            "node": "PHI Data Router",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "PHI Data Router": {
      "main": [
        [
          {
            "node": "Ollama PHI Redaction",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "DeepSeek Generate Cypher",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Ollama PHI Redaction": {
      "main": [
        [
          {
            "node": "Merge Redacted Query",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Merge Redacted Query": {
      "main": [
        [
          {
            "node": "DeepSeek Generate Cypher",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "DeepSeek Generate Cypher": {
      "main": [
        [
          {
            "node": "Validate & Sanitize Cypher",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Validate & Sanitize Cypher": {
      "main": [
        [
          {
            "node": "Execute Dynamic Cypher",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Execute Dynamic Cypher": {
      "main": [
        [
          {
            "node": "Evaluate Cache Results",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Evaluate Cache Results": {
      "main": [
        [
          {
            "node": "Cache Hit Router",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Cache Hit Router": {
      "main": [
        [
          {
            "node": "Format Cached Response",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "OpenClaw Research Fetch",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Format Cached Response": {
      "main": [
        [
          {
            "node": "Audit Log Entry",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "OpenClaw Research Fetch": {
      "main": [
        [
          {
            "node": "Process OpenClaw Results",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Process OpenClaw Results": {
      "main": [
        [
          {
            "node": "Ollama Data Validation",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Ollama Data Validation": {
      "main": [
        [
          {
            "node": "Parse Validation Results",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Parse Validation Results": {
      "main": [
        [
          {
            "node": "Store Entities in Neo4j",
            "type": "main",
            "index": 0
          },
          {
            "node": "Store Relationships in Neo4j",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Store Entities in Neo4j": {
      "main": [
        [
          {
            "node": "Format Fresh Response",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Store Relationships in Neo4j": {
      "main": [
        [
          {
            "node": "Format Fresh Response",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Format Fresh Response": {
      "main": [
        [
          {
            "node": "Audit Log Entry",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Audit Log Entry": {
      "main": [
        [
          {
            "node": "Store Audit Log",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Store Audit Log": {
      "main": [
        [
          {
            "node": "Respond to User",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Daily Maintenance Trigger": {
      "main": [
        [
          {
            "node": "Cleanup Stale Neo4j Data",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Cleanup Stale Neo4j Data": {
      "main": [
        [
          {
            "node": "Verify Neo4j Indexes",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Verify Neo4j Indexes": {
      "main": [
        [
          {
            "node": "Ollama Health Check",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Ollama Health Check": {
      "main": [
        [
          {
            "node": "Ollama Status Check",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Ollama Status Check": {
      "main": [
        [
          {
            "node": "Maintenance Report (OK)",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "Maintenance Report (Alert)",
            "type": "main",
            "index": 0
          }
        ]
      ]
    }
  },
  "settings": {
    "executionOrder": "v1",
    "saveManualExecutions": true,
    "callerPolicy": "workflowsFromSameOwner",
    "errorWorkflow": ""
  },
  "staticData": null,
  "tags": [
    {
      "name": "precision-medicine"
    },
    {
      "name": "production"
    },
    {
      "name": "hipaa-compliant"
    }
  ],
  "pinData": {},
  "versionId": "1.0.0",
  "meta": {
    "instanceId": "precision-medicine-engine-v1",
    "templateCredsSetupCompleted": false
  }
}
